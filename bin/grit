#!/bin/bash

# Examples
# grit push -c
# grit push -c -r upstream
# grit checkout -f [query]

# Constants
push="push"
checkout="checkout"
merge="merge"

getBranch () {
  local branch=""
  local OPTIND opt
  while getopts ":cf:" opt; do
    case $opt in
      "c")
        branch="$(git branch | grep \*)"
        ;;
      "f")
        branch="$(git branch | grep $OPTARG)"
        ;;
    esac
  done

  # TODO
  # Need to provide escape hatch if query returns multiple branches
  # Right now it just returns the first one - no good.

  branch="$(echo "$branch" | sed 's/\*//' | awk '{print $1}')"
  echo "$branch"
}

getRemote () {
  local remote=""
  local OPTIND opt
  while getopts ":r:" opt; do
    case $opt in
      "r")
        remote=$OPTARG
        ;;
      esac
  done
  if [ -z $remote ] ; then
    remote="origin"
  fi
  echo "$remote"
}

getIsPreview () {
  local preview=0
  local OPTIND opt
  while getopts ":p" opt; do
    case $opt in
      "p")
        preview=1
        ;;
    esac
  done
  echo $preview
}

push () {
  local branch="$(getBranch $@)"
  local remote="$(getRemote $@)"
  echo "git push $remote $branch"

  # TODO
  # Allow for force-push (Prompt for input first)
}

checkout () {
  local branch="$(getBranch $@)"
  echo "git checkout $branch"
}

merge () {
  local branch="$(getBranch $@)"
  echo "git merge $branch"
}

grit () {
  local type=$1
  shift

  local cmd=""
  local isPreview="$(getIsPreview $@)"

  if [ $type = $push ] ; then
    cmd="$(push $@)"
  elif [ $type = $checkout ] ; then
    cmd="$(checkout $@)"
  elif [ $type = $merge ] ; then
    cmd="$(merge $@)"
  else
    echo "grit - unrecognized command"
    exit 1
  fi

  if [ "$isPreview" -eq "1" ] ; then
    echo "grit - command preview..."
    echo "$cmd"
  else
    echo "grit - executing command..."
    echo "$cmd"
    eval $cmd
  fi
}

grit "$@"
